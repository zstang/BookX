$@
表示规则的目标文件名。
如果目标是一个文档文件（Linux中，一般称.a文件为文档文件，也称为静态库文件），那么它代表这个文档的文件名。在多目标模式规则中，它代表的是哪个触发规则被执行的目标文件名。
$%
当规则的目标文件是一个静态库文件时，代表静态库的一个成员名。例如，规则的目标是“foo.a(bar.o)”，那么，“$%”的值就为“bar.o”，“$@”的值为“foo.a”。如果目标不是静态库文件，其值为空。
$<
规则的第一个依赖文件名。如果是一个目标文件使用隐含规则来重建，则它代表由隐含规则加入的第一个依赖文件。
$?
所有比目标文件更新的依赖文件列表，空格分割。如果目标是静态库文件名，代表的是库成员（.o文件）。
自动化变量“$?”在显式规则中也是非常有用的，使用它规则可以指定只对更新以后的依赖文件进行操作。例如，静态库文件“libN.a”，它由一些.o文件组成。这个规则实现了只将更新后的.o文件加入到库中：$(TARGET_LIB) : $(OBJS) ; ar -r $(TARGET_LIB) $?
$^
规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有库成员（.o文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的一次引用情况。就是说变量“$^”会去掉重复的依赖文件。
$+
类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。
$*
在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录（斜杠之前）部分）。例如：文件“dir/a.foo.b”，当目标的模式为“%.b”时，“$*”的值为“dir/a.foo”。“茎”对于构造相关文件名非常有用。
自动化变量“$*”需要两点说明：
1.对于一个明确指定的规则来说不存在“茎”，这种情况下“$*”的含义发生改变。此时，如果目标文件名带有一个可识别的后缀，那么“$*”表示文件中除后缀以外的部分。例如：“foo.c”则“$*”的值为：“foo”，因为.c是一个可识别的文件后缀名。GUN make对明确规则的这种奇怪的处理行为是为了和其它版本的make兼容。通常，在除静态规则和模式规则以外，明确指定目标文件的规则中应该避免使用这个变量。
2.当明确指定文件名的规则中目标文件名包含不可识别的后缀时，此变量为空。
